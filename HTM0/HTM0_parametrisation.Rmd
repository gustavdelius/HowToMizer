---
title: "How to Mizer - how to parametrise a Mizer model"
author: "Julia L. Blanchard, Ken H. Andersen, Gustav Delius, Romain Forestier"
date: "`r Sys.Date()`"
place: Hobart, Australia
output:
  html_document: default
  # pdf_document: default
always_allow_html: true
#runtime: shiny
---


```{r set up, message = F}

source("../utility.R")


```


# Beginner level tutorial - how to parameterise a Mizer model

In this tutorial you will learn 

- What type of data is needed to parametrise a Mizer model

- How to convert raw data into a `mizerParams` object

- Check the several assumptions you are making about your parameters

- Explore the model for the first time with your own data set




## Step 1 - What data are typically needed

In this section you will:

- learn what data you need to run Mizer


First you are going to need a data frame of species specfic parameters to input into the `newMultispeciesParams()` function. This function requires at least three columns of parameters:

- species name (`species`)
- asymptotic size (`w_inf`)
- maximum intake rate (`h`) or von Bertalanffy growth parameter (`k_vb`)

The data frame is arranged as species by parameter, so each column of the parameter data frame is a parameter and each row has the values of the parameters for one of the species in the model.

You will also need an interaction matrix that defines the overlapping interaction between each species (default is set to 1, meaning full time overlap). Usually when species' interactions are set to 1, no species can coexist as preys are always eaten by predators.

All other parameters either have default values or will be calculated from the supplied parameters.


```{r step 1 - small example}

smallExample <- data.frame("species" = c("george","ginette"),"w_inf" = c(1.6,1.7), "k_vb" = c(.6,1))
smallExample
smallInter <- matrix(c(.2,.4,.1,.3),ncol = 2, dimnames = list(smallExample$species,smallExample$species))
smallInter
```

The set of species' specific parameters for the North Sea is availalble in the "How to Mizer" GitHub repository as shown below.

```{r step 0 - initial parameters, message= F }


# loading North Sea data
nsParams <- read.csv("../data/nsparams.csv")[,-1]

# This data frame already has Rmax values, let's remove them to calibrate them again later
nsParams[,"r_max"] <- Inf
# ordering by asymptotic size for color gradient
nsParams <- nsParams[order(nsParams$w_inf),] 
# need to order the interaction matrix as well | it's so ugly please help
inter <- select(as.data.frame(inter),nsParams$species)
inter <- as.matrix(select(as.data.frame(t(inter)),nsParams$species))

# If you want to make it less multi-species and more trait-based model
# nsParams[,"beta"] <-100
# nsParams[,"sigma"] <-1.5

nsParams

inter


```



The second type of data you are going to need is a data set of catch and/or biomass of the selected species, so we can compare the model output's to real data. The fisheries time-series of the North Sea are also avaible on this repository.

The following .csv are extracted from the ICES database using "data/getICESFishdata_param.R". Fishing data is averaged over 2014-2019 as it is a relatively stable period in catches and has the maximum amount of data across all species concerned.

```{r step 1 - loading data}

# fisheries mortality F
fMat <- read.csv("../data/fmat.csv")
# fMatWeighted <- read.csv("data/fmatWeighted.csv") # Sandeel and Cod have multiple data base so average their F and weighting by SSB
fMatWeighted <- readRDS("../data/FmatWeightedInterpolated.rds") # to get Gurnard data


# read in time-averaged  catches  
catchAvg <-read.csv("../data/time-averaged-catches.csv") # only that one is used at the moment | catches are estimated from fMatW

# ssb
ssbAvg <- read.csv("../data/time-averaged-SSB.csv")

```



```{r step 1 - visual representation of the data, warning=F}

# plot_dat <- reshape2::melt(fMatWeighted,"X")
# colnames(plot_dat) <- c("Time", "Species", "F")
# 
# ggplot(plot_dat)+
#   geom_line(aes(x = Time, y = F, color = Species))+
#   scale_y_continuous(name = "Fisheries mortality rate") +
#   scale_color_manual(values = params_uncalibrated@linecolour) +
#   theme(                   panel.background = element_blank(),
#                    panel.grid.minor = element_line(color = "gray"),
#                    legend.key = element_rect(fill = "white"))



# overlapping fisheries mortality with next plot

# plot_dat <- apply(as.matrix(fMatWeighted[67:73,]),2,mean, na.rm = T)
# plot_dat <- plot_dat[2:length(plot_dat)]
# plot_dat <- melt(plot_dat)
# plot_dat$Species <- factor(as.character(rownames(plot_dat)),levels = c(as.character(params_uncalibrated@species_params$species)))
# plot_dat <- plot_dat[order(plot_dat$Species),]
# plot_dat$w_inf <- params_uncalibrated@species_params$w_inf
# plot_dat2 <- plot_dat

  
plot_dat <- data.frame(catchAvg,ssbAvg)
plot_dat$species.1 <- NULL
colnames(plot_dat) <- c("Species", "average catch", "average SSB")
plot_dat$Species <- factor(as.character(plot_dat$Species),levels = c(as.character(nsParams$species)))
plot_dat <- reshape2::melt(plot_dat,"Species")
plot_dat$w_inf <- rep(nsParams$w_inf,2)

  
  # ggplot(plot_dat) +
  #   geom_bar(aes(x = Species,y = value, fill = Species, alpha = variable), stat = "identity", position = position_dodge()) +
  #   geom_point(aes(x = Species))
  #   scale_y_continuous(trans = "log10", name = "Catch (clear) and SSB (solid)") + #, limits = c(0.5*min(plot_dat$value),NA)) +
  #   scale_fill_manual(name = "Species", values = params_uncalibrated@linecolour) +
  #   scale_alpha_manual(name = "Stat", values = c(0.5, 1), labels = c("Catch", "SSB")) +
  #   theme(
  #         legend.position = "none", legend.key = element_rect(fill = "white"))
    
 

ggplot(plot_dat)+
  geom_point(aes(x = w_inf, y = value, color = Species, shape = variable), size = 6, alpha = .8) +
  # geom_point(data = plot_dat2, aes(x = w_inf, y = value*1562500, color = Species, shape = "averaged fishing mortality"), size = 6, alpha = .8)+
  geom_text_repel(data = filter(plot_dat,variable == "average SSB"), aes(x = w_inf, y = value, label = Species), hjust = 0, nudge_x = 0.05)+
  geom_line(aes(x = w_inf, y = value, color = Species)) +
  scale_y_continuous(name = "Catch and SSB", limits = c(0,NA)) +#,sec.axis = sec_axis(trans = ~./1562500)) +
  scale_x_continuous(name = "Asymptotic size (g)", trans = "log10") +
  scale_color_manual(name = "Species", values = viridis(dim(nsParams)[1])) +
  scale_shape_manual(name = "Data", values = c(16,17)) + # add 4 if fisheries mortality present
  theme(panel.background = element_blank(),
        panel.grid.minor = element_line(color = "gray"),
        legend.position = "bottom",legend.key = element_rect(fill = "white"))+
  guides(color = FALSE)



```

This plot shows the averaged data over the 2014-2019 period. Species are ordered per asympotic size on the x-axis. There are 2 data points per species. The average catch (disc) and average SSB (triangle) are linked by a line. Units is ...
RF: Dab and Gurnard have some issues, it comes from the data though, the calculations are correct.




## Step 2 - How to convert the data into a valid `mizerParams` object


In this section you will:

- learn to format raw data into a Mizer compatible format

Inputing the previous data frame and interaction matrix into the `newMultispeciesParams()` function output a fully fleshed `mizerParams` object


```{r step 2 - mizerParams example}
param <- newMultispeciesParams(smallExample,smallInter)
param@species_params
```

Let's do the same for our North Sea data set and look at what parameters we can find in the `mizerParams` object:


```{r step 2 - mizerParams NS}

params_uncalibrated <- newMultispeciesParams(nsParams, inter, kappa = 1e11, max_w=1e6) # inter comes with loading "mizer"

params_uncalibrated@species_params$erepro <- .01 # default is 1

# note the volume of this model is set to the reflect the entire volume of the North Sea - hence the very large kappa value. This is system specific and you may wnat to work with per m^3 as in the defaults.

#  Add other params for info
#  param$Volumecubicmetres=5.5e13    #unit of volume. Here total volume of North sea is used (Andersen & Ursin 1977)

# have a look at species parameters that have been calculated
# params_uncalibrated@species_params

# alternative params without redundant parameters to reduce the size of the dataframe on the screeen
params_uncalibrated@species_params[,-which(colnames(params_uncalibrated@species_params) %in% 
                                             c("sel_func","gear","interaction_resource","pred_kernel_type","m","alpha","n","p","q","w_min"))]

```

```{r step 0 - color scheme, include=F}
# params_uncalibrated@species_params <- params_uncalibrated@species_params[order(params_uncalibrated@species_params$w_inf),] # ordering by asymptotic size for color gradient


# lets' change the plotting colours, by far the hardest and trickiest part

# looks good but hard to distinguish some species

params_uncalibrated@linecolour[1:12] <-viridis(dim(params_uncalibrated@species_params)[1])

# easier to read plots but color meaningless
# library(pals)
# params_uncalibrated@linecolour[1:12] <-glasbey(dim(params_uncalibrated@species_params)[1])

# Gradient over asymptotic size but might get difficult to distinguish species past 9
# colfunc <- colorRampPalette(c("firebrick3","darkturquoise", "orange"))
# colGrad <- colfunc(dim(params_uncalibrated@species_params)[1])
#  #names(colGrad) <- params_uncalibrated@species_params$species[order(params_uncalibrated@species_params$w_inf)] # gradient is ordered per winf
# 
# params_uncalibrated@linecolour[1:12] <- colGrad
# 
params_uncalibrated@linecolour["Resource"] <-"seagreen3"

# jet.colors <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan", "#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000","maroon4"))
# params_uncalibrated@linecolour[1:12] <-jet.colors(dim(params_uncalibrated@species_params)[1])

# write color routine for color gradient readable but related to winf (can use my usual one but limited to ~9 species for clarity
# maybe have different color depening on species number

# line width related to asymptotic size ?
```

w_inf: asymptotic size

w_mat: maturation size (determines when 50% of the population has matured / not sure!)

beta: preferred predator/prey mass ratio

sigma: width of the feeding kernel

R_max: Beverton-Holt density dependence parameter

k_vb: von Bertalanffy growth parameter

l25: length at ...

l50: length at ...

a: coefficient for age to size conversion

b: constant for age to size conversion

catchability: fisheries efficiency

h: maximum intake rate

k: metabolism constant

ks: metabolism coefficient

z0: background mortality coefficient

gamma: search volume (obtained from beta and sigma)

w_mat25: weight at which 25% of individuals are mature

erepro: coefficent that weights reproductive output


## Step 3 - Checking assumptions

In this section you will:

???

## Step 4 - Running and exploring the model for the first time to check coexistence (e.g. first guess)

In this section you will:

- Try to get coexistence between your species manually

First, let's use the `project()` function with our `mizerParams` object to project in time our initial ecosystem and see if species manage to coexist together. 


```{r step 3 - first run, message=F, warning = F}

# run with fishing
sim_uncalibrated <- project(params_uncalibrated, t_max = 100, effort = 1)

plotSummary(sim_uncalibrated, short = T)

```

The top panel shows the different species size spectrum at the last time step of the simulation while the bottom panel shows the abundance per species through time.
These plots show that species do not coexist and several go extinct. This is because there was no external density dependence ($R_{max}$ is set at $Inf$) and the largest species (Cod and Saithe) are out-competing the rest.



To get coexistence one needs to guess reasonable $R_{max}$ values which will stop out-competition from a few species. We assume that a the density dependence is going to be posively related to body size, meaning that large individuals will have a stronger density-dependence applied to them (and therefore a lower $R_{max}$ value)





```{r step 3 - guessing coexistence, warning=F, message=F}

# let's start again and replace with the initial pre-calibration "guessed" Rmax 
params_guessed <- params_uncalibrated
# penalise the large species with higher density dependence
params_guessed@species_params$R_max <- params_guessed@resource_params$kappa*params_guessed@species_params$w_inf^-1
# and reduce erepro
# params_guessed@species_params$erepro <- 1e-3

params_guessed <- setParams(params_guessed)
# run with fishing
sim_guessed <- project(params_guessed, t_max = 100, effort =1)
plotSummary(sim_guessed, short = T)


```

The ecosystem looks way better. Saithe's largest individuals are having a hard time, but at least species coexist.

$R_{max}$ affects the density-dependent reproduction rate ($RDD$) but limiting the maximum amout of spawn calculated from the density-independent reproduction rate ($RDI$). Let's look at the $RDD/RDI$ ratio to see how strong acts $R_{max}$ on our different species.


```{r step 3 - RDD/RDI}

  plot_dat <- as.data.frame(getRDD(sim_guessed@params)/getRDI(sim_guessed@params))
  plot_dat$species <- factor(rownames(plot_dat),sim_guessed@params@species_params$species)
  colnames(plot_dat)[1] <- "ratio"
  plot_dat$w_inf <- sim_guessed@params@species_params$w_inf

# ggplot(plot_dat) +
#   geom_bar(aes(x = species, y = ratio, fill = species),stat="identity") +
#   scale_fill_manual(name = "Species", values = sim_guessed@params@linecolour) +
#   scale_y_continuous(name = "density-independent / density-dependent reproduction rate", trans = "log10") +
#   scale_x_discrete(name = "Species") +
#    theme(panel.background = element_rect(fill = "white", color = "black"),
#         legend.position = "none")

ggplot(plot_dat)+
  geom_point(aes(x = w_inf, y = ratio, color = species), size = 6, alpha = .8) +
  geom_text(aes(x = w_inf, y = ratio, label = species), hjust = 0, nudge_x = 0.05)+
  # geom_line(aes(x = w_inf, y = value, color = Species)) +
  scale_y_continuous(name = "density-independent / density-dependent reproduction rate", limits = c(0,1)) +
  scale_x_continuous(name = "Asymptotic size (g)", trans = "log10") +
  scale_color_manual(name = "Species", values = params_uncalibrated@linecolour) +
  theme(panel.background = element_blank(),
                   panel.grid.minor = element_line(color = "gray"),
       legend.position = "none")








```


Is the physiological recruitment, $RDI$, much higher than the realised recruitment, $RDD$? Low $RDD/RDI$ ratio indicates strong density dependence, meaning that the carrying capacity is controlling the population rather than predation or competition. Larger species often require more of this density dependent control than smaller ones. If $RDD/RDI$ is too low, the efficiency of reproduction ($erepro$) can be lowered to ensure species do not outcompete others or or over-resilient to fishing. The largest species that were the most limited by our new $R_{max}$ do not show a strong density dependence. The medium-sized species are the most affected here.







